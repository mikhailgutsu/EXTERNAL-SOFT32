#include <windows.h>
#include <iostream>
#include <vector>
#include <TlHelp32.h>

DWORD GetProcessID(const char* processName) {
    DWORD processID = 0;
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hSnapshot != INVALID_HANDLE_VALUE) {
        PROCESSENTRY32 pe;
        pe.dwSize = sizeof(PROCESSENTRY32);
        if (Process32First(hSnapshot, &pe)) {
            do {
                if (!_stricmp(pe.szExeFile, processName)) {
                    processID = pe.th32ProcessID;
                    break;
                }
            } while (Process32Next(hSnapshot, &pe));
        }
        CloseHandle(hSnapshot);
    }
    return processID;
}

template <typename T>
T ReadMemory(HANDLE hProcess, DWORD address) {
    T value;
    ReadProcessMemory(hProcess, (LPCVOID)address, &value, sizeof(T), NULL);
    return value;
}

int main() {
    const char* targetProcess = "target_game.exe";
    DWORD playerBaseAddress = 0x12345678;
    DWORD xOffset = 0x50; //X
    DWORD yOffset = 0x54; //Y
    DWORD zOffset = 0x58; //Z

    DWORD processID = GetProcessID(targetProcess);
    if (processID == 0) {
        std::cerr << "Process not found!" << std::endl;
        return 1;
    }

    HANDLE hProcess = OpenProcess(PROCESS_VM_READ, FALSE, processID);
    if (hProcess == NULL) {
        std::cerr << "ERR!" << std::endl;
        return 1;
    }

    while (true) {
        float playerX = ReadMemory<float>(hProcess, playerBaseAddress + xOffset);
        float playerY = ReadMemory<float>(hProcess, playerBaseAddress + yOffset);
        float playerZ = ReadMemory<float>(hProcess, playerBaseAddress + zOffset);

        std::cout << "COO: X=" << playerX << " Y=" << playerY << " Z=" << playerZ << std::endl;

        Sleep(1000);
    }

    CloseHandle(hProcess);
    return 0;
}
